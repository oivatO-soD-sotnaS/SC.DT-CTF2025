{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/otavio/Documents/SC.DT-CTF2025/ctf-01/app/%28private%29/YOU%2527ILL%2520NEVER%2520GUESS/_components/Orb.tsx"],"sourcesContent":["\"use client\"\n\nimport { useEffect, useRef } from \"react\";\nimport { Renderer, Program, Mesh, Triangle, Vec3 } from \"ogl\";\n\ninterface OrbProps {\n  hue?: number;\n  hoverIntensity?: number;\n  rotateOnHover?: boolean;\n  forceHoverState?: boolean;\n}\n\nexport default function Orb({\n  hue = 0,\n  hoverIntensity = 0.2,\n  rotateOnHover = true,\n  forceHoverState = false,\n}: OrbProps) {\n  const ctnDom = useRef<HTMLDivElement>(null);\n\n  const vert = /* glsl */ `\n    precision highp float;\n    attribute vec2 position;\n    attribute vec2 uv;\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = vec4(position, 0.0, 1.0);\n    }\n  `;\n\n  const frag = /* glsl */ `\n    precision highp float;\n\n    uniform float iTime;\n    uniform vec3 iResolution;\n    uniform float hue;\n    uniform float hover;\n    uniform float rot;\n    uniform float hoverIntensity;\n    varying vec2 vUv;\n\n    vec3 rgb2yiq(vec3 c) {\n      float y = dot(c, vec3(0.299, 0.587, 0.114));\n      float i = dot(c, vec3(0.596, -0.274, -0.322));\n      float q = dot(c, vec3(0.211, -0.523, 0.312));\n      return vec3(y, i, q);\n    }\n    \n    vec3 yiq2rgb(vec3 c) {\n      float r = c.x + 0.956 * c.y + 0.621 * c.z;\n      float g = c.x - 0.272 * c.y - 0.647 * c.z;\n      float b = c.x - 1.106 * c.y + 1.703 * c.z;\n      return vec3(r, g, b);\n    }\n    \n    vec3 adjustHue(vec3 color, float hueDeg) {\n      float hueRad = hueDeg * 3.14159265 / 180.0;\n      vec3 yiq = rgb2yiq(color);\n      float cosA = cos(hueRad);\n      float sinA = sin(hueRad);\n      float i = yiq.y * cosA - yiq.z * sinA;\n      float q = yiq.y * sinA + yiq.z * cosA;\n      yiq.y = i;\n      yiq.z = q;\n      return yiq2rgb(yiq);\n    }\n    \n    vec3 hash33(vec3 p3) {\n      p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\n      p3 += dot(p3, p3.yxz + 19.19);\n      return -1.0 + 2.0 * fract(vec3(\n        p3.x + p3.y,\n        p3.x + p3.z,\n        p3.y + p3.z\n      ) * p3.zyx);\n    }\n    \n    float snoise3(vec3 p) {\n      const float K1 = 0.333333333;\n      const float K2 = 0.166666667;\n      vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n      vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n      vec3 e = step(vec3(0.0), d0 - d0.yzx);\n      vec3 i1 = e * (1.0 - e.zxy);\n      vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n      vec3 d1 = d0 - (i1 - K2);\n      vec3 d2 = d0 - (i2 - K1);\n      vec3 d3 = d0 - 0.5;\n      vec4 h = max(0.6 - vec4(\n        dot(d0, d0),\n        dot(d1, d1),\n        dot(d2, d2),\n        dot(d3, d3)\n      ), 0.0);\n      vec4 n = h * h * h * h * vec4(\n        dot(d0, hash33(i)),\n        dot(d1, hash33(i + i1)),\n        dot(d2, hash33(i + i2)),\n        dot(d3, hash33(i + 1.0))\n      );\n      return dot(vec4(31.316), n);\n    }\n    \n    vec4 extractAlpha(vec3 colorIn) {\n      float a = max(max(colorIn.r, colorIn.g), colorIn.b);\n      return vec4(colorIn.rgb / (a + 1e-5), a);\n    }\n    \n    const vec3 baseColor1 = vec3(0.611765, 0.262745, 0.996078);\n    const vec3 baseColor2 = vec3(0.298039, 0.760784, 0.913725);\n    const vec3 baseColor3 = vec3(0.062745, 0.078431, 0.600000);\n    const float innerRadius = 0.6;\n    const float noiseScale = 0.65;\n    \n    float light1(float intensity, float attenuation, float dist) {\n      return intensity / (1.0 + dist * attenuation);\n    }\n    \n    float light2(float intensity, float attenuation, float dist) {\n      return intensity / (1.0 + dist * dist * attenuation);\n    }\n    \n    vec4 draw(vec2 uv) {\n      vec3 color1 = adjustHue(baseColor1, hue);\n      vec3 color2 = adjustHue(baseColor2, hue);\n      vec3 color3 = adjustHue(baseColor3, hue);\n      \n      float ang = atan(uv.y, uv.x);\n      float len = length(uv);\n      float invLen = len > 0.0 ? 1.0 / len : 0.0;\n      \n      float n0 = snoise3(vec3(uv * noiseScale, iTime * 0.5)) * 0.5 + 0.5;\n      float r0 = mix(mix(innerRadius, 1.0, 0.4), mix(innerRadius, 1.0, 0.6), n0);\n      float d0 = distance(uv, (r0 * invLen) * uv);\n      float v0 = light1(1.0, 10.0, d0);\n      v0 *= smoothstep(r0 * 1.05, r0, len);\n      float cl = cos(ang + iTime * 2.0) * 0.5 + 0.5;\n      \n      float a = iTime * -1.0;\n      vec2 pos = vec2(cos(a), sin(a)) * r0;\n      float d = distance(uv, pos);\n      float v1 = light2(1.5, 5.0, d);\n      v1 *= light1(1.0, 50.0, d0);\n      \n      float v2 = smoothstep(1.0, mix(innerRadius, 1.0, n0 * 0.5), len);\n      float v3 = smoothstep(innerRadius, mix(innerRadius, 1.0, 0.5), len);\n      \n      vec3 col = mix(color1, color2, cl);\n      col = mix(color3, col, v0);\n      col = (col + v1) * v2 * v3;\n      col = clamp(col, 0.0, 1.0);\n      \n      return extractAlpha(col);\n    }\n    \n    vec4 mainImage(vec2 fragCoord) {\n      vec2 center = iResolution.xy * 0.5;\n      float size = min(iResolution.x, iResolution.y);\n      vec2 uv = (fragCoord - center) / size * 2.0;\n      \n      float angle = rot;\n      float s = sin(angle);\n      float c = cos(angle);\n      uv = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n      \n      uv.x += hover * hoverIntensity * 0.1 * sin(uv.y * 10.0 + iTime);\n      uv.y += hover * hoverIntensity * 0.1 * sin(uv.x * 10.0 + iTime);\n      \n      return draw(uv);\n    }\n    \n    void main() {\n      vec2 fragCoord = vUv * iResolution.xy;\n      vec4 col = mainImage(fragCoord);\n      gl_FragColor = vec4(col.rgb * col.a, col.a);\n    }\n  `;\n\n  useEffect(() => {\n    const container = ctnDom.current;\n    if (!container) return;\n\n    const renderer = new Renderer({ alpha: true, premultipliedAlpha: false });\n    const gl = renderer.gl;\n    gl.clearColor(0, 0, 0, 0);\n    container.appendChild(gl.canvas);\n\n    const geometry = new Triangle(gl);\n    const program = new Program(gl, {\n      vertex: vert,\n      fragment: frag,\n      uniforms: {\n        iTime: { value: 0 },\n        iResolution: {\n          value: new Vec3(\n            gl.canvas.width,\n            gl.canvas.height,\n            gl.canvas.width / gl.canvas.height\n          ),\n        },\n        hue: { value: hue },\n        hover: { value: 0 },\n        rot: { value: 0 },\n        hoverIntensity: { value: hoverIntensity },\n      },\n    });\n\n    const mesh = new Mesh(gl, { geometry, program });\n\n    function resize() {\n      if (!container) return;\n      const dpr = window.devicePixelRatio || 1;\n      const width = container.clientWidth;\n      const height = container.clientHeight;\n      renderer.setSize(width * dpr, height * dpr);\n      gl.canvas.style.width = width + \"px\";\n      gl.canvas.style.height = height + \"px\";\n      program.uniforms.iResolution.value.set(\n        gl.canvas.width,\n        gl.canvas.height,\n        gl.canvas.width / gl.canvas.height\n      );\n    }\n    window.addEventListener(\"resize\", resize);\n    resize();\n\n    let targetHover = 0;\n    let lastTime = 0;\n    let currentRot = 0;\n    const rotationSpeed = 0.3;\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const rect = container.getBoundingClientRect();\n      const x = e.clientX - rect.left;\n      const y = e.clientY - rect.top;\n      const width = rect.width;\n      const height = rect.height;\n      const size = Math.min(width, height);\n      const centerX = width / 2;\n      const centerY = height / 2;\n      const uvX = ((x - centerX) / size) * 2.0;\n      const uvY = ((y - centerY) / size) * 2.0;\n\n      if (Math.sqrt(uvX * uvX + uvY * uvY) < 0.8) {\n        targetHover = 1;\n      } else {\n        targetHover = 0;\n      }\n    };\n\n    const handleMouseLeave = () => {\n      targetHover = 0;\n    };\n\n    container.addEventListener(\"mousemove\", handleMouseMove);\n    container.addEventListener(\"mouseleave\", handleMouseLeave);\n\n    let rafId: number;\n    const update = (t: number) => {\n      rafId = requestAnimationFrame(update);\n      const dt = (t - lastTime) * 0.001;\n      lastTime = t;\n      program.uniforms.iTime.value = t * 0.001;\n      program.uniforms.hue.value = hue;\n      program.uniforms.hoverIntensity.value = hoverIntensity;\n\n      const effectiveHover = forceHoverState ? 1 : targetHover;\n      program.uniforms.hover.value += (effectiveHover - program.uniforms.hover.value) * 0.1;\n\n      if (rotateOnHover && effectiveHover > 0.5) {\n        currentRot += dt * rotationSpeed;\n      }\n      program.uniforms.rot.value = currentRot;\n\n      renderer.render({ scene: mesh });\n    };\n    rafId = requestAnimationFrame(update);\n\n    return () => {\n      cancelAnimationFrame(rafId);\n      window.removeEventListener(\"resize\", resize);\n      container.removeEventListener(\"mousemove\", handleMouseMove);\n      container.removeEventListener(\"mouseleave\", handleMouseLeave);\n      container.removeChild(gl.canvas);\n      gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n    };\n  }, [hue, hoverIntensity, rotateOnHover, forceHoverState]);\n\n  return <div ref={ctnDom} className=\"w-full h-full\" />;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 301, "column": 0}, "map": {"version":3,"sources":["file:///home/otavio/Documents/SC.DT-CTF2025/ctf-01/app/%28private%29/YOU%2527ILL%2520NEVER%2520GUESS/_components/FuzzyText.tsx"],"sourcesContent":["\"use client\"\n\nimport React, { useEffect, useRef } from \"react\";\n\ninterface FuzzyTextProps {\n  children: React.ReactNode;\n  fontSize?: number | string;\n  fontWeight?: string | number;\n  fontFamily?: string;\n  color?: string;\n  enableHover?: boolean;\n  baseIntensity?: number;\n  hoverIntensity?: number;\n}\n\nconst FuzzyText: React.FC<FuzzyTextProps> = ({\n  children,\n  fontSize = \"3rem\",\n  fontWeight = 900,\n  fontFamily = \"inherit\",\n  color = \"#fff\",\n  enableHover = true,\n  baseIntensity = 0.18,\n  hoverIntensity = 0.5,\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement & { cleanupFuzzyText?: () => void}>(null);\n\n  useEffect(() => {\n    let animationFrameId: number;\n    let isCancelled = false;\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const init = async () => {\n      if (document.fonts?.ready) {\n        await document.fonts.ready;\n      }\n      if (isCancelled) return;\n\n      const ctx = canvas.getContext(\"2d\");\n      if (!ctx) return;\n\n      const computedFontFamily =\n        fontFamily === \"inherit\"\n          ? window.getComputedStyle(canvas).fontFamily || \"sans-serif\"\n          : fontFamily;\n\n      const fontSizeStr =\n        typeof fontSize === \"number\" ? `${fontSize}px` : fontSize;\n      let numericFontSize: number;\n      if (typeof fontSize === \"number\") {\n        numericFontSize = fontSize;\n      } else {\n        const temp = document.createElement(\"span\");\n        temp.style.fontSize = fontSize;\n        document.body.appendChild(temp);\n        const computedSize = window.getComputedStyle(temp).fontSize;\n        numericFontSize = parseFloat(computedSize);\n        document.body.removeChild(temp);\n      }\n\n      const text = React.Children.toArray(children).join(\"\");\n\n      const offscreen = document.createElement(\"canvas\");\n      const offCtx = offscreen.getContext(\"2d\");\n      if (!offCtx) return;\n\n      offCtx.font = `${fontWeight} ${fontSizeStr} ${computedFontFamily}`;\n      offCtx.textBaseline = \"alphabetic\";\n      const metrics = offCtx.measureText(text);\n\n      const actualLeft = metrics.actualBoundingBoxLeft ?? 0;\n      const actualRight = metrics.actualBoundingBoxRight ?? metrics.width;\n      const actualAscent = metrics.actualBoundingBoxAscent ?? numericFontSize;\n      const actualDescent =\n        metrics.actualBoundingBoxDescent ?? numericFontSize * 0.2;\n\n      const textBoundingWidth = Math.ceil(actualLeft + actualRight);\n      const tightHeight = Math.ceil(actualAscent + actualDescent);\n\n      const extraWidthBuffer = 10;\n      const offscreenWidth = textBoundingWidth + extraWidthBuffer;\n\n      offscreen.width = offscreenWidth;\n      offscreen.height = tightHeight;\n\n      const xOffset = extraWidthBuffer / 2;\n      offCtx.font = `${fontWeight} ${fontSizeStr} ${computedFontFamily}`;\n      offCtx.textBaseline = \"alphabetic\";\n      offCtx.fillStyle = color;\n      offCtx.fillText(text, xOffset - actualLeft, actualAscent);\n\n      const horizontalMargin = 50;\n      const verticalMargin = 0;\n      canvas.width = offscreenWidth + horizontalMargin * 2;\n      canvas.height = tightHeight + verticalMargin * 2;\n      ctx.translate(horizontalMargin, verticalMargin);\n\n      const interactiveLeft = horizontalMargin + xOffset;\n      const interactiveTop = verticalMargin;\n      const interactiveRight = interactiveLeft + textBoundingWidth;\n      const interactiveBottom = interactiveTop + tightHeight;\n\n      let isHovering = false;\n      const fuzzRange = 30;\n\n      const run = () => {\n        if (isCancelled) return;\n        ctx.clearRect(\n          -fuzzRange,\n          -fuzzRange,\n          offscreenWidth + 2 * fuzzRange,\n          tightHeight + 2 * fuzzRange\n        );\n        const intensity = isHovering ? hoverIntensity : baseIntensity;\n        for (let j = 0; j < tightHeight; j++) {\n          const dx = Math.floor(intensity * (Math.random() - 0.5) * fuzzRange);\n          ctx.drawImage(\n            offscreen,\n            0,\n            j,\n            offscreenWidth,\n            1,\n            dx,\n            j,\n            offscreenWidth,\n            1\n          );\n        }\n        animationFrameId = window.requestAnimationFrame(run);\n      };\n\n      run();\n\n      const isInsideTextArea = (x: number, y: number) =>\n        x >= interactiveLeft &&\n        x <= interactiveRight &&\n        y >= interactiveTop &&\n        y <= interactiveBottom;\n\n      const handleMouseMove = (e: MouseEvent) => {\n        if (!enableHover) return;\n        const rect = canvas.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        isHovering = isInsideTextArea(x, y);\n      };\n\n      const handleMouseLeave = () => {\n        isHovering = false;\n      };\n\n      const handleTouchMove = (e: TouchEvent) => {\n        if (!enableHover) return;\n        e.preventDefault();\n        const rect = canvas.getBoundingClientRect();\n        const touch = e.touches[0];\n        const x = touch.clientX - rect.left;\n        const y = touch.clientY - rect.top;\n        isHovering = isInsideTextArea(x, y);\n      };\n\n      const handleTouchEnd = () => {\n        isHovering = false;\n      };\n\n      if (enableHover) {\n        canvas.addEventListener(\"mousemove\", handleMouseMove);\n        canvas.addEventListener(\"mouseleave\", handleMouseLeave);\n        canvas.addEventListener(\"touchmove\", handleTouchMove, {\n          passive: false,\n        });\n        canvas.addEventListener(\"touchend\", handleTouchEnd);\n      }\n\n      const cleanup = () => {\n        window.cancelAnimationFrame(animationFrameId);\n        if (enableHover) {\n          canvas.removeEventListener(\"mousemove\", handleMouseMove);\n          canvas.removeEventListener(\"mouseleave\", handleMouseLeave);\n          canvas.removeEventListener(\"touchmove\", handleTouchMove);\n          canvas.removeEventListener(\"touchend\", handleTouchEnd);\n        }\n      };\n\n      canvas.cleanupFuzzyText = cleanup;\n    };\n\n    init();\n\n    return () => {\n      isCancelled = true;\n      window.cancelAnimationFrame(animationFrameId);\n      if (canvas && canvas.cleanupFuzzyText) {\n        canvas.cleanupFuzzyText();\n      }\n    };\n  }, [\n    children,\n    fontSize,\n    fontWeight,\n    fontFamily,\n    color,\n    enableHover,\n    baseIntensity,\n    hoverIntensity,\n  ]);\n\n  return <canvas ref={canvasRef} />;\n};\n\nexport default FuzzyText;\n"],"names":[],"mappings":"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","debugId":null}}]
}