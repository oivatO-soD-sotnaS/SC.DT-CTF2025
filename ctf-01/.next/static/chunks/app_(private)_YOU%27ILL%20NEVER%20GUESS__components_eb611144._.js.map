{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/otavio/Documents/SC.DT-CTF2025/ctf-01/app/%28private%29/YOU%2527ILL%2520NEVER%2520GUESS/_components/Orb.tsx"],"sourcesContent":["\"use client\"\n\nimport { useEffect, useRef } from \"react\";\nimport { Renderer, Program, Mesh, Triangle, Vec3 } from \"ogl\";\n\ninterface OrbProps {\n  hue?: number;\n  hoverIntensity?: number;\n  rotateOnHover?: boolean;\n  forceHoverState?: boolean;\n}\n\nexport default function Orb({\n  hue = 0,\n  hoverIntensity = 0.2,\n  rotateOnHover = true,\n  forceHoverState = false,\n}: OrbProps) {\n  const ctnDom = useRef<HTMLDivElement>(null);\n\n  const vert = /* glsl */ `\n    precision highp float;\n    attribute vec2 position;\n    attribute vec2 uv;\n    varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = vec4(position, 0.0, 1.0);\n    }\n  `;\n\n  const frag = /* glsl */ `\n    precision highp float;\n\n    uniform float iTime;\n    uniform vec3 iResolution;\n    uniform float hue;\n    uniform float hover;\n    uniform float rot;\n    uniform float hoverIntensity;\n    varying vec2 vUv;\n\n    vec3 rgb2yiq(vec3 c) {\n      float y = dot(c, vec3(0.299, 0.587, 0.114));\n      float i = dot(c, vec3(0.596, -0.274, -0.322));\n      float q = dot(c, vec3(0.211, -0.523, 0.312));\n      return vec3(y, i, q);\n    }\n    \n    vec3 yiq2rgb(vec3 c) {\n      float r = c.x + 0.956 * c.y + 0.621 * c.z;\n      float g = c.x - 0.272 * c.y - 0.647 * c.z;\n      float b = c.x - 1.106 * c.y + 1.703 * c.z;\n      return vec3(r, g, b);\n    }\n    \n    vec3 adjustHue(vec3 color, float hueDeg) {\n      float hueRad = hueDeg * 3.14159265 / 180.0;\n      vec3 yiq = rgb2yiq(color);\n      float cosA = cos(hueRad);\n      float sinA = sin(hueRad);\n      float i = yiq.y * cosA - yiq.z * sinA;\n      float q = yiq.y * sinA + yiq.z * cosA;\n      yiq.y = i;\n      yiq.z = q;\n      return yiq2rgb(yiq);\n    }\n    \n    vec3 hash33(vec3 p3) {\n      p3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\n      p3 += dot(p3, p3.yxz + 19.19);\n      return -1.0 + 2.0 * fract(vec3(\n        p3.x + p3.y,\n        p3.x + p3.z,\n        p3.y + p3.z\n      ) * p3.zyx);\n    }\n    \n    float snoise3(vec3 p) {\n      const float K1 = 0.333333333;\n      const float K2 = 0.166666667;\n      vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n      vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n      vec3 e = step(vec3(0.0), d0 - d0.yzx);\n      vec3 i1 = e * (1.0 - e.zxy);\n      vec3 i2 = 1.0 - e.zxy * (1.0 - e);\n      vec3 d1 = d0 - (i1 - K2);\n      vec3 d2 = d0 - (i2 - K1);\n      vec3 d3 = d0 - 0.5;\n      vec4 h = max(0.6 - vec4(\n        dot(d0, d0),\n        dot(d1, d1),\n        dot(d2, d2),\n        dot(d3, d3)\n      ), 0.0);\n      vec4 n = h * h * h * h * vec4(\n        dot(d0, hash33(i)),\n        dot(d1, hash33(i + i1)),\n        dot(d2, hash33(i + i2)),\n        dot(d3, hash33(i + 1.0))\n      );\n      return dot(vec4(31.316), n);\n    }\n    \n    vec4 extractAlpha(vec3 colorIn) {\n      float a = max(max(colorIn.r, colorIn.g), colorIn.b);\n      return vec4(colorIn.rgb / (a + 1e-5), a);\n    }\n    \n    const vec3 baseColor1 = vec3(0.611765, 0.262745, 0.996078);\n    const vec3 baseColor2 = vec3(0.298039, 0.760784, 0.913725);\n    const vec3 baseColor3 = vec3(0.062745, 0.078431, 0.600000);\n    const float innerRadius = 0.6;\n    const float noiseScale = 0.65;\n    \n    float light1(float intensity, float attenuation, float dist) {\n      return intensity / (1.0 + dist * attenuation);\n    }\n    \n    float light2(float intensity, float attenuation, float dist) {\n      return intensity / (1.0 + dist * dist * attenuation);\n    }\n    \n    vec4 draw(vec2 uv) {\n      vec3 color1 = adjustHue(baseColor1, hue);\n      vec3 color2 = adjustHue(baseColor2, hue);\n      vec3 color3 = adjustHue(baseColor3, hue);\n      \n      float ang = atan(uv.y, uv.x);\n      float len = length(uv);\n      float invLen = len > 0.0 ? 1.0 / len : 0.0;\n      \n      float n0 = snoise3(vec3(uv * noiseScale, iTime * 0.5)) * 0.5 + 0.5;\n      float r0 = mix(mix(innerRadius, 1.0, 0.4), mix(innerRadius, 1.0, 0.6), n0);\n      float d0 = distance(uv, (r0 * invLen) * uv);\n      float v0 = light1(1.0, 10.0, d0);\n      v0 *= smoothstep(r0 * 1.05, r0, len);\n      float cl = cos(ang + iTime * 2.0) * 0.5 + 0.5;\n      \n      float a = iTime * -1.0;\n      vec2 pos = vec2(cos(a), sin(a)) * r0;\n      float d = distance(uv, pos);\n      float v1 = light2(1.5, 5.0, d);\n      v1 *= light1(1.0, 50.0, d0);\n      \n      float v2 = smoothstep(1.0, mix(innerRadius, 1.0, n0 * 0.5), len);\n      float v3 = smoothstep(innerRadius, mix(innerRadius, 1.0, 0.5), len);\n      \n      vec3 col = mix(color1, color2, cl);\n      col = mix(color3, col, v0);\n      col = (col + v1) * v2 * v3;\n      col = clamp(col, 0.0, 1.0);\n      \n      return extractAlpha(col);\n    }\n    \n    vec4 mainImage(vec2 fragCoord) {\n      vec2 center = iResolution.xy * 0.5;\n      float size = min(iResolution.x, iResolution.y);\n      vec2 uv = (fragCoord - center) / size * 2.0;\n      \n      float angle = rot;\n      float s = sin(angle);\n      float c = cos(angle);\n      uv = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n      \n      uv.x += hover * hoverIntensity * 0.1 * sin(uv.y * 10.0 + iTime);\n      uv.y += hover * hoverIntensity * 0.1 * sin(uv.x * 10.0 + iTime);\n      \n      return draw(uv);\n    }\n    \n    void main() {\n      vec2 fragCoord = vUv * iResolution.xy;\n      vec4 col = mainImage(fragCoord);\n      gl_FragColor = vec4(col.rgb * col.a, col.a);\n    }\n  `;\n\n  useEffect(() => {\n    const container = ctnDom.current;\n    if (!container) return;\n\n    const renderer = new Renderer({ alpha: true, premultipliedAlpha: false });\n    const gl = renderer.gl;\n    gl.clearColor(0, 0, 0, 0);\n    container.appendChild(gl.canvas);\n\n    const geometry = new Triangle(gl);\n    const program = new Program(gl, {\n      vertex: vert,\n      fragment: frag,\n      uniforms: {\n        iTime: { value: 0 },\n        iResolution: {\n          value: new Vec3(\n            gl.canvas.width,\n            gl.canvas.height,\n            gl.canvas.width / gl.canvas.height\n          ),\n        },\n        hue: { value: hue },\n        hover: { value: 0 },\n        rot: { value: 0 },\n        hoverIntensity: { value: hoverIntensity },\n      },\n    });\n\n    const mesh = new Mesh(gl, { geometry, program });\n\n    function resize() {\n      if (!container) return;\n      const dpr = window.devicePixelRatio || 1;\n      const width = container.clientWidth;\n      const height = container.clientHeight;\n      renderer.setSize(width * dpr, height * dpr);\n      gl.canvas.style.width = width + \"px\";\n      gl.canvas.style.height = height + \"px\";\n      program.uniforms.iResolution.value.set(\n        gl.canvas.width,\n        gl.canvas.height,\n        gl.canvas.width / gl.canvas.height\n      );\n    }\n    window.addEventListener(\"resize\", resize);\n    resize();\n\n    let targetHover = 0;\n    let lastTime = 0;\n    let currentRot = 0;\n    const rotationSpeed = 0.3;\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const rect = container.getBoundingClientRect();\n      const x = e.clientX - rect.left;\n      const y = e.clientY - rect.top;\n      const width = rect.width;\n      const height = rect.height;\n      const size = Math.min(width, height);\n      const centerX = width / 2;\n      const centerY = height / 2;\n      const uvX = ((x - centerX) / size) * 2.0;\n      const uvY = ((y - centerY) / size) * 2.0;\n\n      if (Math.sqrt(uvX * uvX + uvY * uvY) < 0.8) {\n        targetHover = 1;\n      } else {\n        targetHover = 0;\n      }\n    };\n\n    const handleMouseLeave = () => {\n      targetHover = 0;\n    };\n\n    container.addEventListener(\"mousemove\", handleMouseMove);\n    container.addEventListener(\"mouseleave\", handleMouseLeave);\n\n    let rafId: number;\n    const update = (t: number) => {\n      rafId = requestAnimationFrame(update);\n      const dt = (t - lastTime) * 0.001;\n      lastTime = t;\n      program.uniforms.iTime.value = t * 0.001;\n      program.uniforms.hue.value = hue;\n      program.uniforms.hoverIntensity.value = hoverIntensity;\n\n      const effectiveHover = forceHoverState ? 1 : targetHover;\n      program.uniforms.hover.value += (effectiveHover - program.uniforms.hover.value) * 0.1;\n\n      if (rotateOnHover && effectiveHover > 0.5) {\n        currentRot += dt * rotationSpeed;\n      }\n      program.uniforms.rot.value = currentRot;\n\n      renderer.render({ scene: mesh });\n    };\n    rafId = requestAnimationFrame(update);\n\n    return () => {\n      cancelAnimationFrame(rafId);\n      window.removeEventListener(\"resize\", resize);\n      container.removeEventListener(\"mousemove\", handleMouseMove);\n      container.removeEventListener(\"mouseleave\", handleMouseLeave);\n      container.removeChild(gl.canvas);\n      gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n    };\n  }, [hue, hoverIntensity, rotateOnHover, forceHoverState]);\n\n  return <div ref={ctnDom} className=\"w-full h-full\" />;\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 167, "column": 0}, "map": {"version":3,"sources":["file:///home/otavio/Documents/SC.DT-CTF2025/ctf-01/app/%28private%29/YOU%2527ILL%2520NEVER%2520GUESS/_components/FuzzyText.tsx"],"sourcesContent":["\"use client\"\n\nimport React, { useEffect, useRef } from \"react\";\n\ninterface FuzzyTextProps {\n  children: React.ReactNode;\n  fontSize?: number | string;\n  fontWeight?: string | number;\n  fontFamily?: string;\n  color?: string;\n  enableHover?: boolean;\n  baseIntensity?: number;\n  hoverIntensity?: number;\n}\n\nconst FuzzyText: React.FC<FuzzyTextProps> = ({\n  children,\n  fontSize = \"3rem\",\n  fontWeight = 900,\n  fontFamily = \"inherit\",\n  color = \"#fff\",\n  enableHover = true,\n  baseIntensity = 0.18,\n  hoverIntensity = 0.5,\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement & { cleanupFuzzyText?: () => void}>(null);\n\n  useEffect(() => {\n    let animationFrameId: number;\n    let isCancelled = false;\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const init = async () => {\n      if (document.fonts?.ready) {\n        await document.fonts.ready;\n      }\n      if (isCancelled) return;\n\n      const ctx = canvas.getContext(\"2d\");\n      if (!ctx) return;\n\n      const computedFontFamily =\n        fontFamily === \"inherit\"\n          ? window.getComputedStyle(canvas).fontFamily || \"sans-serif\"\n          : fontFamily;\n\n      const fontSizeStr =\n        typeof fontSize === \"number\" ? `${fontSize}px` : fontSize;\n      let numericFontSize: number;\n      if (typeof fontSize === \"number\") {\n        numericFontSize = fontSize;\n      } else {\n        const temp = document.createElement(\"span\");\n        temp.style.fontSize = fontSize;\n        document.body.appendChild(temp);\n        const computedSize = window.getComputedStyle(temp).fontSize;\n        numericFontSize = parseFloat(computedSize);\n        document.body.removeChild(temp);\n      }\n\n      const text = React.Children.toArray(children).join(\"\");\n\n      const offscreen = document.createElement(\"canvas\");\n      const offCtx = offscreen.getContext(\"2d\");\n      if (!offCtx) return;\n\n      offCtx.font = `${fontWeight} ${fontSizeStr} ${computedFontFamily}`;\n      offCtx.textBaseline = \"alphabetic\";\n      const metrics = offCtx.measureText(text);\n\n      const actualLeft = metrics.actualBoundingBoxLeft ?? 0;\n      const actualRight = metrics.actualBoundingBoxRight ?? metrics.width;\n      const actualAscent = metrics.actualBoundingBoxAscent ?? numericFontSize;\n      const actualDescent =\n        metrics.actualBoundingBoxDescent ?? numericFontSize * 0.2;\n\n      const textBoundingWidth = Math.ceil(actualLeft + actualRight);\n      const tightHeight = Math.ceil(actualAscent + actualDescent);\n\n      const extraWidthBuffer = 10;\n      const offscreenWidth = textBoundingWidth + extraWidthBuffer;\n\n      offscreen.width = offscreenWidth;\n      offscreen.height = tightHeight;\n\n      const xOffset = extraWidthBuffer / 2;\n      offCtx.font = `${fontWeight} ${fontSizeStr} ${computedFontFamily}`;\n      offCtx.textBaseline = \"alphabetic\";\n      offCtx.fillStyle = color;\n      offCtx.fillText(text, xOffset - actualLeft, actualAscent);\n\n      const horizontalMargin = 50;\n      const verticalMargin = 0;\n      canvas.width = offscreenWidth + horizontalMargin * 2;\n      canvas.height = tightHeight + verticalMargin * 2;\n      ctx.translate(horizontalMargin, verticalMargin);\n\n      const interactiveLeft = horizontalMargin + xOffset;\n      const interactiveTop = verticalMargin;\n      const interactiveRight = interactiveLeft + textBoundingWidth;\n      const interactiveBottom = interactiveTop + tightHeight;\n\n      let isHovering = false;\n      const fuzzRange = 30;\n\n      const run = () => {\n        if (isCancelled) return;\n        ctx.clearRect(\n          -fuzzRange,\n          -fuzzRange,\n          offscreenWidth + 2 * fuzzRange,\n          tightHeight + 2 * fuzzRange\n        );\n        const intensity = isHovering ? hoverIntensity : baseIntensity;\n        for (let j = 0; j < tightHeight; j++) {\n          const dx = Math.floor(intensity * (Math.random() - 0.5) * fuzzRange);\n          ctx.drawImage(\n            offscreen,\n            0,\n            j,\n            offscreenWidth,\n            1,\n            dx,\n            j,\n            offscreenWidth,\n            1\n          );\n        }\n        animationFrameId = window.requestAnimationFrame(run);\n      };\n\n      run();\n\n      const isInsideTextArea = (x: number, y: number) =>\n        x >= interactiveLeft &&\n        x <= interactiveRight &&\n        y >= interactiveTop &&\n        y <= interactiveBottom;\n\n      const handleMouseMove = (e: MouseEvent) => {\n        if (!enableHover) return;\n        const rect = canvas.getBoundingClientRect();\n        const x = e.clientX - rect.left;\n        const y = e.clientY - rect.top;\n        isHovering = isInsideTextArea(x, y);\n      };\n\n      const handleMouseLeave = () => {\n        isHovering = false;\n      };\n\n      const handleTouchMove = (e: TouchEvent) => {\n        if (!enableHover) return;\n        e.preventDefault();\n        const rect = canvas.getBoundingClientRect();\n        const touch = e.touches[0];\n        const x = touch.clientX - rect.left;\n        const y = touch.clientY - rect.top;\n        isHovering = isInsideTextArea(x, y);\n      };\n\n      const handleTouchEnd = () => {\n        isHovering = false;\n      };\n\n      if (enableHover) {\n        canvas.addEventListener(\"mousemove\", handleMouseMove);\n        canvas.addEventListener(\"mouseleave\", handleMouseLeave);\n        canvas.addEventListener(\"touchmove\", handleTouchMove, {\n          passive: false,\n        });\n        canvas.addEventListener(\"touchend\", handleTouchEnd);\n      }\n\n      const cleanup = () => {\n        window.cancelAnimationFrame(animationFrameId);\n        if (enableHover) {\n          canvas.removeEventListener(\"mousemove\", handleMouseMove);\n          canvas.removeEventListener(\"mouseleave\", handleMouseLeave);\n          canvas.removeEventListener(\"touchmove\", handleTouchMove);\n          canvas.removeEventListener(\"touchend\", handleTouchEnd);\n        }\n      };\n\n      canvas.cleanupFuzzyText = cleanup;\n    };\n\n    init();\n\n    return () => {\n      isCancelled = true;\n      window.cancelAnimationFrame(animationFrameId);\n      if (canvas && canvas.cleanupFuzzyText) {\n        canvas.cleanupFuzzyText();\n      }\n    };\n  }, [\n    children,\n    fontSize,\n    fontWeight,\n    fontFamily,\n    color,\n    enableHover,\n    baseIntensity,\n    hoverIntensity,\n  ]);\n\n  return <canvas ref={canvasRef} />;\n};\n\nexport default FuzzyText;\n"],"names":[],"mappings":"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","debugId":null}}]
}